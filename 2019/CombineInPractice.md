# WWDC 2019 - Combine in Practice

https://developer.apple.com/videos/play/wwdc2019/721/

# 먼저 컴바인이 뭔지 다시 짚고 가자
코드 짤 때, 어떤 값과 관련된 퍼블리셔와 그 값의 변화에 관심이 있는 섭스크라이버가 있기 마련이다.
그럼 이제 연결을 수립하고, 섭스크라이버는 종종 request를 보내고, 퍼블리셔는 값을 보내고. 
퍼블리셔가 값을 다 보냈거나, 중간에 오류가 났거나, 구독을 캔슬하기로 결정했거나 등등 할 때까지 계속된다.
이런 커뮤니케이션의 모양은 콜백, 클로저 등과 유사하다.

그리고 이게 컴바인의 모양새와 같다.
다시 말하지만, 컴바인은 "시간에 따른 값의 처리에 관한 통합적∙선언적 API"이다.

# Publisher
인트로에서 말했듯 Publisher 프로토콜을 만족해야 퍼블리셔로서 기능할 수 있다.
Output, Failure 제네릭이 있다. 그리고 이 타입들과 매치되는 Subscriber를 인자로 받는 subscribe 메서드가 있다.

cf. Subscriber"가" 구독한다기보다, Publisher"를" 구독한다고 이해하면, 왜 Publisher에 subscribe 메서드가 있는지 조금은 더 쉽게 이해될 수도 있겠다.

NotificationCenter에 있는 static method publisher(for:) 를 활용해보자.
이 메서드는 사실, 노티피케이션 센터를 컴바인에서 활용하기 위해 만들어진 것이다. 원래 노티 센터에서 특정 알림에 대한 동작을 수행하려면 objc 함수를 사용해야 했던 것을 생각해 보자. 그것을 컴바인으로 대체한 것.

### 오퍼레이터
map을 통해 내부의 데이터를 변경할 수 있다.
tryMap을 통해 오류가 날 수 있는 구문을 클로저 안에 넣을 수 있다.
특별히 디코딩의 경우, 심플하게 decode(타입, 디코더) 메서드를 이용할 수 있다.

## 에러 핸들링
모든 퍼블리셔는 어떤 오류가 나는지 알고 있다. 오류의 타입을 정해 준다는 말이다. 또한 잘 핸들링되어야 한다. 이것을 위해서 사용되는 오퍼레이터도 있다.

### 오퍼레이터
assertNoFailure 오퍼레이터를 넣음으로써, 에러가 나왔을 때 fatalError를 통해 앱을 깨뜨릴 수 있다.
retry를 통해 오류가 났다면 재시도할 수 있다.
catch를 통해 퍼블리셔에 난 오류를 감지하고, 업스트림을 종료시킨 다음 대체할 복구 퍼블리셔를 연결해줄 수 있다.
    예시 상황에서는 Just 퍼블리셔를 통해 Placeholder를 반환했다. 이로써 오류가 나지 않고, 오류 타입은 Never인 스트림이 완성.
    하지만! 우리가 원하는 건 실패했을 때 placeholder를 내보내고 성공했을 때는 제대로 결과값을 받는 것인데..
flatMap. 업스트림 퍼블리셔를 받아서, 새로운 퍼블리셔를 만든다는 것을 전제한다.
    값을 받아서 새로운 Just 퍼블리셔로 만들고 동작을 수행하는 클로저를 가져온다. 그리고 이것을 구독함으로써, 다운스트림에 값을 발신한다.
    이 원리를 통해 flatMap 안에 catch 따위를 정의한 다음, 어쨌든 새로운 퍼블리셔로 만들어서 구독하고, 이걸 값으로 다운스트림에 내려 줌으로써 노티피케이션이 끊기는 것을 방지할 수 있다. 어쨌든 새로운 Just를 구독하는 거니까!
mapError를 통해 에러의 타입을 바꿀 수 있다.
setFailureType을 통해 에러 상황에서 새로운 에러 타입을 반환할 수 있다.
publisher 오퍼레이터와 적절한 KeyPath를 통해 자료형 중에서 원하는 값을 발신해줄 수도 있다.

### 스케줄드 오퍼레이터
언제, 어디로 이벤트를 전달하느냐 하는 것을 말해줄 수 있으며, RunLoop와 DispatchQueue가 도와준다구
delay를 통해 좀 이따 이벤트를 발신할 수 있다.
throttle을 통해 일정 주기 미만의 이벤트는 안 보내게 할 수 있다.
receive(on:)을 통해 Publisher를 정의하며, 다운스트림 구독자들이 어느 특정 스레드/루프 등에서 이벤트를 받을지 정해줄 수 있다. UI 업데이트라던지 하는 것들.
subscribe(on:)을 통해 특정 구독자가 퍼블리셔를 어느 특정 스레드/루프 등에서 구독할지 정해줄 수 있다.

Just를 통한 동기적 발신, NotiCenter를 통한 비동기적 발신.

# Subscriber
Input, Failure 제네릭이 있다.
receive 세 가지 메서드가 있다. 각각 구독, 값, 연결 종료를 매개변수로 받는다.

섭스크라이버가 구독을 하면, 퍼블리셔는 구독 receive 메서드를 단 한번 불러온다.
섭스크라이버가 요청하면, 퍼블리셔는 값 receive 메서드를 통해 0개 이상의 값을 다운스트림에 발신한다.
퍼블리셔는 최대 1개의 completion을 보낼 수 있으며, 이 경우 구독 종료를 원했거나 에러가 발생했거나 하는 케이스다. 이 이후로는 값이 더 이상 넘어오지 않는다. (Rx의 onError, onComplete와 같다고 보여진다.) 종료는 optional이다. 무한한 스트림도 많기 때문.

## 여러 종류의 Subscriber
기본적으로, 퍼블리셔에 assign과 적절한 KeyPath를 통해 섭스크라이버를 생성하는 방법이 있다.
    참조. 컴바인에 내장된 cancellation은, 구독을 조기에 종료시키고자 할 때 사용한다. Cancellable 프로토콜이 있고, 이를 채택한 AnyCancellable 구현체가 있으며, 이 구현체는 cancel 메서드를 deinit될 때 호출한다.
다음으로, sink 오퍼레이터를 통해 섭스크라이버를 만들 수 있다. 클로저를 가지고, 받아온 모든 값을 컨트롤할 수 있다. 
    sink는 Cancellable을 리턴한다.

### Subjects
Publisher가 될 수도 있고 Subscriber가 될 수도 있는 녀석. 여러 개의 구독자에게 값을 발신한다.
send 메서드가 두 가지 있는데, 파라미터로 값과 completion을 받는다.
PassThroughSubject와 CurrentValue가 있다. 전자는 Rx의 PublishSubject같은 거고, 후자는 거기에 더해 가장 나중에 이 스트림을 거쳐 간 값을 저장해 둔다.

### SwiftUI
SwiftUI에는 Subscriber가 내장되어 있다. 의존성만 묘사해 주면 되고, 나머지는 프레임워크가 알아서 해 주는 유형. 선언형 UI란 이런 걸까..?
Publisher를 제공하고, 데이터가 언제 어떻게 바뀌는지만 정해 주면 된다는 거다.
SwiftUI의 BindableObject 프로토콜을 보면, PublisherType은 에러가 Never인 퍼블리셔이다. 그리고 didChange 연산 프로퍼티에서 이 PublisherType을 받는다.
@ObjectBinding을 통해 모델을 바인딩하고, 그 변화를 UI에 바로 반영해줄 수 있다.
Data Flow in SwiftUI 세션 참조

## Combine 적용 (대략 23분부터)
조합이라는 키워드를 염두에 두고 만들어졌다. 작은 퍼블리셔와 오퍼레이터가 합쳐져 큰 효과를 내는 것.
디바이스 안에서의 동기적 액션, 서버와 통신하는 비동기적 액션, 모두 컴바인으로 묶어 줄 수 있다.
- 프로퍼티에 @Published 더해서 퍼블리셔로 만들어 주기. 어떤 프로퍼티든 가능하다구~
    - 얘를 퍼블리셔로 인식하려면 사용되는 부분에 $ 접두문자를 붙여줘야 한다.
- 두 가지의 값이 같은지 검증할 때 CombineLatest를 사용할 수 있다.
- Map 타입과 삼항 연산자를 통해 기본 조건을 만족하는 특정 비밀번호를 걸러줄 수도 있다.
- eraseToAnyPublisher()를 통해 필요한 값 자체만 발신할 수 있다. 퍼블리셔들은 특정한 타입을 가질 수 있는데, 이 오퍼레이터는 이 퍼블리셔의 타입을 AnyPublisher로 바꿔 줌으로써 그것을 숨겨 주는 역할을 한다. 좀 더 범용성 있는 타입을 얻을 수 있는 것.
- 빠르게 값이 바뀌는 것 하나하나를 이벤트로 발신하지 않기 위해, debounce 오퍼레이터를 사용할 수 있다.
- removeDuplicates() 오퍼레이터를 통해 같은 값을 계속 이벤트로 받지 않게끔 한다.
- Future를 통해 비동기적으로 오는 값을 처리할 수 있다. promise를 파라미터로 받으며, promise는 (Result<Output, Failure> -> Void) 클로저다.
- 비밀번호를 검증하는 동기적 로직, 그리고 아이디를 검증하는 비동기적 로직을 CombineLatest로 합쳐서 두 조건을 모두 만족했을 때만 회원가입 버튼을 활성화하게 할 수 있다!
    - receive(on: RunLoop.main)을 통해 메인 런 룹에서 돌아가게 해 주는 것을 잊지 말자. UI 요소니까
