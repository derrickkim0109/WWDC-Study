[WWDC 2019 - Introducing Combine](https://developer.apple.com/videos/play/wwdc2019/722/)

비동기 프로그래밍 -> 바뀌면 바뀐 대로 빠르게 반영되게 하는 것이 기본.
예시에서는 타깃/액션, 서버 부하를 막기 위한 타이머, 그리고 KVO를 사용했다. 이것이 오직 ID를 감지하기 위해서만! 당연히 거기에 더해지는 여러 가지 비동기적인 처리가 있다.

비동기 인터페이스: 타깃/액션, 노티센터, URLSession, KVO, 애드혹 콜백.
각각 용도가 있고, 각각을 쓰는 것은 큰 문제가 없을지도 모르지만, 같이 엮어서 쓰는 것은 퍽 어려울 수 있다.

## Combine이란?
컴바인은, 시간의 따른 값의 프로세싱에 대한 통합/선언적 API다.
스위프트로 만들어졌으니까, 제네릭같은 스위프트의 기능을 쓸 수 있다. 이건 보일러플레이트를 줄이는 데 도움이 된다.
타입 세이프하다. 컴파일 타임에 오류를 잡아낼 수 있다.
Composition First. 각각의 조각은 쉽고, 이를 합침으로써 많은 것을 할 수 있다.
요청에 의해 작동되어, 메모리 관리와 앱 퍼포먼스를 더 잘 조절할 수 있다.

## 컴바인의 세 가지 컨셉: Publisher, Subscriber, Operator

### Publisher
컴파인의 선언 파트. 값과 에러가 어떻게 만들어지는지 "선언" 한다. 진짜로 만들어지는 것은 아니다.
값 타입이다. struct로 짜였다는 말.
Subscriber의 등록을 허가한다.
정의부의 associatedType 중 Output이 발신하는 값, Failure가 에러를 나타낸다.
각각의 제네릭 타입은 Subscriber의 제네릭 타입과 맞아야 한다. 당연한 말이지만.
Never라는 것이 있다. 에러 발신할 때 넣을 수 있군.
NotificationCenter.Publisher 익스텐션이 있다.

### Subscriber
Publisher의 반대 개념. 값을 받는 부분이며, Publisher가 유한한 수명을 가진 경우 완료시 동작을 포함한다. 값나 상태가 바뀌기 때문에, 참조 타입을 사용한다.
Publisher 프로토콜과 같은 associatedType이 있다.
receive 메서드가 세 가지가 있는데, Subscription을 받고, .Demand를 받고, .Completion을 받을 수 있다.
Subscribers.Assign을 통해 프로퍼티 값을 직접 변경해줄 수 있다. 주어진 객체의 키 패스 - (역슬래시 닷)이 붙는 것 - 에 넘겨받은 값을 직접 할당해 주는 것이다. 보일러플레이트 코드를 줄일 때 유용하다.

패턴을 보자면...
섭스크라이버가 퍼블리셔를 구독함(subscribe 메서드) -> 퍼블리셔가 섭스크라이버에게 receive 메서드를 통해 값을 보냄 -> 섭스크라이버가 퍼블리셔에게 request 메서드를 통해 N개의 값에 대한 요청을 보냄 -> N개 이하의 값을 보냄
하나의 구독에서 하나 이상의 응답과 하나의 컴플리션이 있다.

### Operator
퍼블리셔와 섭스크라이버 사이에서 값을 바꾸거나 더하거나 없애거나 하는 동작을 수행한다. 일종의 퍼블리셔. 다른 퍼블리셔(업스트림)를 구독할 수도 있고, 다른 섭스크라이버(다운스트림)에게 값을 보낼 수 있다.

역시 map이 예시로 나올 줄 알았다. 정확히는 Publishers.Map
Publisher에 map 메서드가 따로 있다. 일종의 문법적 설탕처럼 작동한다.

어사인 메서드는 Cancellable을 리턴한다. 퍼블리셔와 섭스크라이버의 시퀀스를 빠르게 끝내게 한다.

#### 선언적 오퍼레이터 API
map과 같은 고차함수, 리스트 관련 동작, 에러 핸들링, 스레드나 큐 옮기기, 디스패치큐나 런 룹 등과 관련된 스케출링과 시간 관련 동작이 있다.
이런 다양한 오퍼레이터를 조합할 수 있다. 이것이 Composition, 컴바인의 디자인 철학이다.

#### 동기와 비동기로 비유하자면
동기로 하나를 말하는 게 Int고 여러 개를 말하는 게 Array라면, 비동기로는 Future와 Publisher가 될 수 있다.
(시간에 따른 이벤트의 나열이 반응형 프로그래밍 패러다임에 중요한 것을 생각해보자.)
그렇기 때문에 배열에서 할 수 있는 것은 Publisher에서 할 수 있다. compactmap, filter, prefix 등이 예시로 나왔다.

#### 비동기 작업에서의 오퍼레이터
맵과 필터는 좋은 오퍼레이터지만, 동기적 작동을 전제한다. 즉, 처리하려는 값들이 다 있는 상태에서 수행하는 동작이다.
비동기 세계, 즉 처리할 값들이 모두 도착한 게 아닌 상태에서는 이걸 어떻게 다뤄야 할까?
먼저 zip. 여러 개의 업스트림을 하나의 튜플로 바꾼다. 각각의 업스트림으로부터 튜플을 이룰 하나 이상의 값이 전달되면, 그 값들을 묶어서 튜플로 반환한다는 거다.
combineLatest. zip같지만, 업스트림 중 아무거나 바뀌면 된다. 값이 있긴 있어야겠다. 한 번 값이 들어오면, 어느 하나의 업스트림만 바뀌어도 가장 최근의 값을 토대로 튜플을 반환한다.
URLResponse에 대한 decode 오퍼레이터도 있는 건 놀랍다.

참조: https://swifty-cody.tistory.com/87
Special thanks to ChatGPT

예시 앱: https://github.com/radiantchoi/CombineVersusRx
